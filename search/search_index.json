{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Un Sistema de Control de Versiones (Source Control Management o SCM, por sus siglas en ingl\u00e9s) es una herramienta que permite gestionar los cambios en el c\u00f3digo fuente de un proyecto a lo largo del tiempo. </p> <p>Permite ver todas las modificaciones realizadas en el c\u00f3digo. Facilita la colaboraci\u00f3n entre los desarrolladores.</p>"},{"location":"#beneficios-de-un-scm","title":"Beneficios de un SCM","text":"<p>Un SCM permite mantener un historial detallado de todos los cambios realizados en un proyecto, facilitando el seguimiento de qui\u00e9n hizo qu\u00e9 y cu\u00e1ndo. Gracias a esto, los equipos pueden colaborar sin riesgo de sobrescribir el trabajo de otros.</p> <p>Adem\u00e1s, ofrece la posibilidad de crear ramas y versiones independientes, lo que permite probar nuevas ideas sin afectar la versi\u00f3n principal del c\u00f3digo.</p> <p>Otro aspecto clave es la seguridad, ya que almacena copias de respaldo y permite gestionar los accesos para evitar p\u00e9rdidas de informaci\u00f3n.</p> <p>Por \u00faltimo, si ocurre un error o falla en el desarrollo, se puede revertir f\u00e1cilmente a una versi\u00f3n anterior sin mayores complicaciones.</p>"},{"location":"#tipos-de-scm","title":"Tipos de SCM","text":"<ol> <li>Centralizados (CVCS - Centralized Version Control Systems): Un servidor central almacena todas las versiones del c\u00f3digo y los desarrolladores obtienen una copia local. Ejemplo: Subversion (SVN).</li> <li>Distribuidos (DVCS - Distributed Version Control Systems): Cada desarrollador tiene una copia completa del repositorio, lo que permite trabajar sin conexi\u00f3n y mejorar la seguridad. Ejemplos: Git, Mercurial.</li> </ol>"},{"location":"#ejemplos-de-scm-populares","title":"Ejemplos de SCM populares","text":"<ul> <li>Git: El m\u00e1s utilizado actualmente, con herramientas como GitHub, GitLab y Bitbucket.</li> <li>Subversion (SVN): Popular en entornos empresariales m\u00e1s tradicionales.</li> <li>Mercurial: Similar a Git, pero con un enfoque m\u00e1s simple en algunos aspectos.</li> </ul>"},{"location":"git/Comandos%20Basicos%20de%20Git/","title":"Trabajando con Git","text":"<p>Para iniciar un repositorio de Git (Carpeta en la que se va a aplicar el control de versiones) ejecutaremos:</p> <pre><code>git init\n</code></pre> <p>Este comando crear\u00e1 una carpeta oculta <code>.git</code> en la que se guardar\u00e1 toda la informaci\u00f3n, esta carpeta no debemos tocarla.</p> <p>Una vez inicializado el repositorio podremos ya empezar a guardar las versiones del proyecto.</p>"},{"location":"git/Comandos%20Basicos%20de%20Git/#commits","title":"Commits","text":"<p>Un \"commit\" en Git es un registro de cambios en un repositorio de c\u00f3digo. Se usa para guardar los cambios que has realizado en los archivos del proyecto, junto con un mensaje descriptivo que explica qu\u00e9 cambios se han realizado.</p> <p>Los mensajes deben de ser descriptivos. De nada sirve un mensaje que ponga <code>gfhfgh</code> a la hora de buscar un error en el c\u00f3digo.</p> <p>Para hacer un commit se pasan por dos etapas, una etapa de <code>stage</code>. En esta etapa se marcan los archivos que se quieran commitear.</p> <p>Para esto se utiliza el commando:</p> <pre><code>git add path/to/the/file.java\n</code></pre> <p>Si quieres a\u00f1adir todos los cambios, puedes hacerlo mediante el uso de <code>.</code> o <code>*</code></p> <pre><code>git add .\n</code></pre> <p>Con <code>git status</code> podremos ver que archivos estan en stage,  los que no, los que rastrea o no el repositorio...</p> <p>Para commitear los cambios marcados en etapa stage usaremos:</p> <pre><code>git commit -m \"Mensaje del commit\"\n</code></pre> <p>Con el parametro <code>-m</code> le inicamos el mensaje, si no lo incluimos se abrir\u00e1 el editor que tengamos y ah\u00ed pondremos el mensaje.</p> <p>Para commitear todos los cambios y saltarnos la etapa de stage podremos usar el parametro <code>-a</code>:</p> <pre><code>git commit -am \"Ejemplo\"\n</code></pre> <p>Este <code>-a</code> viene de decir quiero comitear todo, hay gente que se salta el <code>git add</code> indicando que archivos quiero comitear en el commit:</p> <pre><code>git commit index.html -m \"Mensaje del commit\"\n</code></pre> <p>Advertencia: Si un archivo no est\u00e1 siendo rastreado (por ejemplo, reci\u00e9n creado), git commit -a no lo incluir\u00e1, por lo que es importante usar git add para rastrear esos archivos nuevos.</p> <p>Y simplemente utilizan el git add para indicar que el repo rastre los archivos recien creados:</p> <pre><code>git add -A # A mayuscula los archivos que todavia no se estan rastreando, eliminados, modificados... Todos los archivos presentes\n</code></pre> <p>Personalmente prefiero usar git add por coherencia.</p> <p>Para quitar un archivo de stage simplemente ejecute:</p> <pre><code>git rm --cached archivo/a/quitar.md\n</code></pre>"},{"location":"git/Comandos%20Basicos%20de%20Git/#historial-de-commits","title":"Historial de Commits","text":"<p>Si queremos ver el historial de commits que hemos hecho a lo largo del desarrollo podemos usar el comando <code>git log</code>. Este nos muestra el historial junto con los ids de los commits que utilizaremos m\u00e1s tarde. Mi forma favorita de hacerlo es mediante los flags de:</p> <pre><code>git log --oneline --graph\n</code></pre> <p>El cual te los muestra en forma de grafo de las diferentes ramas y el commit te lo muestra en una sola linea.</p>"},{"location":"git/Comandos%20Basicos%20de%20Git/#diferencias-entre-los-commits","title":"Diferencias entre los Commits","text":"<p>El comando <code>git diff</code> es muy \u00fatil, permite ver las diferencias entre distintos estados de un repositorio.</p> <p>Sirve para visualizar diferencias entre distintas cosas, por ejemplo si ejecutas <code>git diff</code> ves la diferencia entre lo que hay en el directorio de trabajo y lo que hay en stage. Tambi\u00e9n sirve para ver la diferencia entre el stage y el \u00faltimo commit <code>git diff --cached</code>, esto puede ser \u00fatil para revisar los cambios antes de commitearlos.</p> <p>Los m\u00e1s \u00fatiles bajo mi opini\u00f3n son:</p> <pre><code>git diff # El equivalente a git diff HEAD\n</code></pre> <p>Que muestra las diferencias entre el directorio de trabajo y el \u00faltimo commit. Si le a\u00f1ades el flag <code>--cached</code> muestra solamente los que estan en stage.</p> <p>Para ver la diferencia de dos commits:</p> <pre><code>git diff &lt;commit1&gt; &lt;commit2&gt;\n</code></pre> <p>Este muestra la diferencia entre dos commits. (Tienes que pasar el identificador del commit, <code>git log</code>). Si solo a\u00f1ades 1 lo hace con el directorio actual.</p> <p>Para ver un archivo concreto, a esto, usa:</p> <pre><code>git diff &lt;commit1&gt; &lt;commit2&gt; -- ruta/del/archivo\n</code></pre> <p>Si simplemente usas <code>git diff</code> sinn ningun id de commit, puedes omitirte las dos <code>--</code>.</p>"},{"location":"git/Comandos%20Basicos%20de%20Git/#correccion-de-commits","title":"Correcci\u00f3n de Commits","text":"<p>Si estas trabajando en una serie de cambios y haces commit pero te das cuenta que tienes que realizar cambios, siempre puedes alterar el \u00faltimo commit con <code>ammend</code>. Tras enviar a stage el archivo o los archivos que quieres cambiar, ejecutar\u00e1s:</p> <pre><code>git commit --amend\n</code></pre> <p>Esto abrir\u00e1 tu editor de texto predeterminado con el mensaje del commit anterior. Puedes editar el mensaje si lo deseas. Guarda los cambios y cierra el editor.</p> <p>Si solo quieres cambiar el mensaje del commit, ejecuta esto \u00faltimo sin a\u00f1adir ningun archivo a stage.</p> <p>Advertencia: Hacer esto si todav\u00eda no has hecho un <code>push</code>, si estas trabajando en remoto. Si lo haces cuando ya lo has hecho push, es posible que tendras que hacer:</p> <pre><code>git push --force\n</code></pre> <p>Pero ten en cuenta que hacer esto reescribir\u00e1 la historia del repositorio, lo que podr\u00eda causar problemas si otros colaboradores ya han basado su trabajo en el commit anterior.</p> <p>Una alternativa m\u00e1s segura es:</p> <pre><code>git push --force-with-lease\n</code></pre> <p>Esto es m\u00e1s seguro ya que comprueba si el repositorio ha cambiado, si lo ha hecho el comando falla.</p>"},{"location":"git/Comandos%20Basicos%20de%20Git/#commits-temporales","title":"Commits Temporales","text":"<p>Git stash es una herramienta \u00fatil en Git que te permite guardar temporalmente cambios que a\u00fan no deseas comprometer o deseas apartar temporalmente del \u00e1rea de trabajo.</p> <p>Es especialmente \u00fatil cuando estas trabajando en una rama y sin hacer un commit quieres cambiarte a otra ya que si realizas un cambio de rama perder\u00e1s todos los cambios realizados en ella.</p> <p>Tras a\u00f1adir los cambios a stage (<code>git add</code>) ejecutas:</p> <pre><code>git stash\n</code></pre> <p>Para volver a aplicar los cambios seleccionados puedes usar:</p> <pre><code>git stash apply\n</code></pre> <p>Esto aplicar\u00e1 el \u00faltimo conjunto de cambios almacenados en el stash. Si tienes m\u00faltiples sets de cambios guardados, puedes aplicar uno en particular especificando el identificador del stash. <code>git stash apply stash@{2}</code> </p> <p>Una vez que ya no necesites los cambios puedes borrarlos</p> <pre><code>git stash drop\n</code></pre> <p>Si tienes varios funciona igual usano el identificador. <code>git stash drop stash@{2}</code>.</p> <p>El yo uso es:</p> <pre><code>git stash pop\n</code></pre> <p>Esto aplicar\u00e1 el \u00faltimo set de cambios almacenados en el stash y luego lo eliminar\u00e1 autom\u00e1ticamente del stash.</p> <p>Puedes ver una lista de todos los sets de cambios almacenados en el stash.</p> <pre><code>git stash list\n</code></pre> <p>A partir de git 2.13 se puede nombrar a los stages (Probablemente tengas ya una versi\u00f3n superior ya que esta sali\u00f3 en 2017, en a\u00f1o el el cual la gente flipaba con el meme del cocinero que echa sal).</p> <pre><code>git stash push -m \"Nombre descriptivo para el stash\"\n</code></pre> <p>Por lo que podras utilizar este nombre como el identificador en los <code>apply</code> y <code>drop</code>.</p>"},{"location":"git/Commits%20Avanzados%20Git/","title":"Commits Avanzados","text":"<p>Hasta ahora solo hemos hecho commits de archivos completos, pero si has usado IntelliJ o VSCode te habr\u00e1s dado cuenta que puedes commitear ciertos cambios que t\u00fa selecciones de un archivo mientras que otros no los tocas.</p> <p>Esto en terminal se realiza mediante el siguiente comando:</p> <pre><code>git add -p &lt;archivo&gt;\n</code></pre> <p>Esto te mostrar\u00e1 un men\u00fa interactivo en el cual t\u00fa eliges que cambios a\u00f1adir o no a\u00f1adir.</p> <pre><code>diff --git a/archivo.txt b/archivo.txt\nindex 4b9b6c2..30304ea 100644\n--- a/archivo.txt\n+++ b/archivo.txt\n@@ -1,3 +1,5 @@\n Hola\n+Contenido 1\n Contenido en la rama principal\n+Contenido 2\n Esto es un stage\n(1/1) Stage this hunk [y,n,q,a,d,s,e,?]? \n</code></pre> <p>El men\u00fa al principio no parace muy intuitivo, pero lo acaba siendo tras un par de usos adem\u00e1s que si no sabes que hace cada letra, si utilizas <code>?</code> te las explica de forma clara.</p> <p>El resumen rapido es:</p> <ul> <li>y - stage this hunk</li> <li>n - do not stage this hunk</li> <li>q - quit; do not stage this hunk or any of the remaining ones</li> <li>a - stage this hunk and all later hunks in the file</li> <li>d - do not stage this hunk or any of the later hunks in the file</li> <li>s - split the current hunk into smaller hunks</li> <li>e - manually edit the current hunk</li> <li>? - print help</li> </ul>"},{"location":"git/Configuracion%20de%20Git/","title":"Configuraci\u00f3n","text":""},{"location":"git/Configuracion%20de%20Git/#instalacion","title":"Instalaci\u00f3n","text":"<p>Para instalar git tienes que ir a su pagina oficial. Descargarte el instalador y ejecutarlo.</p> <p>En el proceso de instalaci\u00f3n, te permitir\u00e1 configurar git. Entre las que destacan la selecci\u00f3n del editor por defecto, por defecto utiliza vim, pero se puede cambiar a VSCode.</p> <p>Tambi\u00e9n esta la del nombre por defecto de la rama principal, si dejamos que Git decida, la nombrar\u00e1 como <code>Master</code>, en este caso aconsejo cambiarla a <code>main</code> que es el nombre est\u00e1ndar que se utiliza actualmente.</p> <p>Una vez instalado, veremos que tendremos instalados varios programas. En windows cabe destacar que tenemos Git CMD y Git Bash, este \u00faltimo es para usarlo como con una terminal de Bash (Linux), en cualquier caso los comandos de Git son exactamente los mismos. Yo los ejecuto desde PowerShell</p> <p>Tambi\u00e9n tenemos instalada Git GUI que es por si no queremos usar la consola pero al trabajar con Git se suele hacer con linea de comandos por lo que no la recomiendo.</p> <p>Para comprobar su correcto funcionamiento ejecutaremos</p> <pre><code>git --version\n</code></pre>"},{"location":"git/Configuracion%20de%20Git/#configuracion-basica","title":"Configuraci\u00f3n b\u00e1sica","text":"<p>Puedes configurar Git desde la linea de comandos con <code>git config</code>, si utilizas tambi\u00e9n el p\u00e1rametro <code>--global</code> la diferencia es que mientras que uno hace una configuracion concreta en un repositorio, con gobal se aplican cambios generales por defecto.</p> <p>Para establecer tu nombre y tu email:</p> <pre><code>git config --global user.name \"Tu nombre\"\ngit config --global user.email \"Email@gmail.com\"\n</code></pre> <p>Para cambiar tu editor por defecto puedes utilizar:</p> <pre><code>git config --global core.editor \"code --wait\"\n</code></pre> <p>Esto lo que hace es establecer code (VSCode) como editor por defecto y esperar a que se cierre el editor. Para cualquier otro editor basta con escibirlo tal y como lo abririas por terminal. <code>notepad</code>, <code>notepad++</code>, <code>vim</code>, <code>nvim</code>, <code>atom</code>...</p> <p>Si no has cambiado la configuraci\u00f3n de master a main, recomiendo que lo hagas, desde terminal se puede hacer con:</p> <pre><code>git config --global init.defaultBranch main\n</code></pre> <p>Si quieres abrir el archivo de configuraci\u00f3n y ediralo en el editor que hayas seleccionado, puedes hacerlo con:</p> <pre><code>git config --global -e\n</code></pre> <p>Siempre puedes ver tu configuraci\u00f3n sin abrir el archivo con:</p> <pre><code>git config --global --list\n</code></pre>"},{"location":"git/Configuracion%20de%20Git/#ayuda","title":"Ayuda","text":"<p>Al igual que en windows o bash con <code>help</code> o <code>man</code> git tiene un manual para saber que hace cada comando.</p> <pre><code>git help # Ayuda de git general\ngit help COMMAND # Ayuda de un comando especifico\n</code></pre>"},{"location":"git/Git/","title":"Introducci\u00f3n a Git","text":"<p>Git es un sistema de control de versiones que te ayuda a rastrear cambios en tus archivos y colaborar con otros en proyectos de software.</p> <p>Con Git, puedes realizar un seguimiento de las diferentes versiones de tus archivos, revertir cambios si es necesario y fusionar el trabajo de diferentes personas de manera eficiente.</p> <p>Es especialmente \u00fatil para equipos de desarrollo de software que trabajan en proyectos complejos, ya que proporciona una forma estructurada de gestionar y compartir c\u00f3digo. Con Git, puedes trabajar de forma colaborativa y mantener un historial claro de todos los cambios realizados en tus proyectos.</p>"},{"location":"git/Ramas%20Git/","title":"Ramas en Git","text":"<p>En Git, las ramas son versiones independientes de un proyecto que permiten el desarrollo paralelo de diferentes caracter\u00edsticas o soluciones. Se utilizan para experimentar, aislar cambios, implementar nuevas funcionalidades y mantener versiones estables y de desarrollo separadas. Las ramas facilitan la colaboraci\u00f3n en equipo al proporcionar un entorno flexible para trabajar en diferentes partes del proyecto simult\u00e1neamente.</p> <p>Al trabajar con ramas se utilizan principalmente cuatro comandos: <code>git branch</code>, <code>git switch</code>, <code>git checkout</code> y <code>git merge</code>.</p>"},{"location":"git/Ramas%20Git/#creacion-de-ramas","title":"Creaci\u00f3n de Ramas","text":"<p>El comando <code>git branch</code> sirve principalmente para la creaci\u00f3n y eliminaci\u00f3n de ramas:</p> <pre><code>git branch        # Muestra todas las ramas\ngit branch nueva-rama          # Crea una nueva rama desde HEAD\ngit branch nueva-rama &lt;commit&gt; # Crea una nueva rama desde un commit espec\u00edfico\ngit branch -d rama-a-eliminar  # Borra una rama (solo si ya se hizo merge de ella)\n</code></pre> <p>Otros comandos \u00fatiles:</p> <pre><code>git branch -D &lt;rama&gt;                # Borra una rama sin importar su estado\ngit branch -m nuevo-nombre           # Renombra la rama actual\ngit branch -m antiguo nuevo-nombre   # Renombra una rama espec\u00edfica\ngit branch -a                        # Lista las ramas locales y remotas\ngit branch -r                        # Lista solo las ramas remotas\n</code></pre>"},{"location":"git/Ramas%20Git/#moverse-entre-ramas","title":"Moverse entre Ramas","text":"<p>Para moverse entre ramas hay dos formas: con <code>checkout</code> y con <code>switch</code>.</p>"},{"location":"git/Ramas%20Git/#git-switch-recomendado","title":"<code>git switch</code> (Recomendado)","text":"<p>Desde Git 2.23, se recomienda el uso de <code>git switch</code> para cambiar entre ramas, ya que es m\u00e1s seguro y est\u00e1 dise\u00f1ado espec\u00edficamente para esta tarea.</p> <pre><code>git switch rama1       # Cambia a una rama existente\ngit switch -c rama1    # Crea y cambia a una nueva rama\n</code></pre>"},{"location":"git/Ramas%20Git/#git-checkout-no-recomendado-para-cambiar-de-rama","title":"<code>git checkout</code> (No recomendado para cambiar de rama)","text":"<p>Antes de <code>git switch</code>, <code>git checkout</code> se usaba tanto para cambiar de rama como para restaurar archivos, lo que lo hac\u00eda confuso. Aunque a\u00fan funciona, <code>git switch</code> es la mejor opci\u00f3n para cambiar de rama.</p> <p>Esto no es para que lo uses, sino para que sepas que checkout est\u00e1 obsoleto.</p> <pre><code>git checkout rama1      # Cambia a una rama existente\ngit checkout -b rama1   # Crea y cambia a una nueva rama (equivalente a `switch -c`)\n</code></pre>"},{"location":"git/Ramas%20Git/#combinar-ramas","title":"Combinar Ramas","text":"<p>Cuando quieres combinar ramas se utiliza <code>git merge</code>. Dado el siguiente caso:</p> <p>Si nos encontramos en la rama <code>main</code> y ejecutamos:</p> <pre><code>git merge feature\n</code></pre> <p>A la rama <code>main</code> se le incorporar\u00e1n los cambios de la rama <code>feature</code>.</p>"},{"location":"git/Ramas%20Git/#tipos-de-merge","title":"Tipos de merge:","text":"<ul> <li>Merge con fast-forward: Si <code>main</code> no tiene commits nuevos desde que se cre\u00f3 <code>feature</code>, Git simplemente mover\u00e1 el puntero de <code>main</code> hacia <code>feature</code>.</li> <li>Merge con commit de fusi\u00f3n: Si <code>main</code> y <code>feature</code> tienen cambios distintos, Git crear\u00e1 un commit adicional para fusionar ambos historiales.</li> </ul> <p>Si hay conflictos, Git solicitar\u00e1 que los resuelvas antes de completar el merge.</p> <p>Para confirmar el merge despu\u00e9s de resolver los conflictos:</p> <pre><code>git add .\ngit commit -m \"Resolviendo conflictos en merge\"\n</code></pre>"},{"location":"git/Repositorios%20Remotos%20Git/","title":"Repositorios Remotos Git","text":"<p>Los repositorios que creamos con <code>git init</code> son repositorios locales en nuestro ordenador, pero para trabajar de manera colaborativa se utilizan repositorios remotos.</p> <p>Para crear un repositorio remoto puedes utilizar Github, Gitlab o uno propio que hagas con Gitea.</p> <p>La forma de trabajar con ellos no es muy diferente. No nos vamos a centrar en aspectos concretos de cada plataforma (crear repositorios github, autenticarse, tokens...), solo nos vamos a centrar en como trabajar sobre ellos.</p> <p>Cuando creas un repo en tu ordenador y creas un repositorio remoto, para subir los cambios tienes que decir a git donde va a mandar los cambios.</p> <pre><code>git remote add origin direccion_del_repositorio \n</code></pre> <p>Esto te agrega la direccion al repositorio para trabajar. Origin es el nombre que por convencion, si declaras varios en el mismo repo tienen que tener nombre diferente.</p> <p>Si tienes un repo remoto ya creado, lo tienes que traer a tu dispositivo, para eso clonas el repo:</p> <pre><code>git clone direccion_del_repositorio\n</code></pre> <p>Con el clone ya tiene por defecto el remoto de donde lo clonase con el nombre origin, si quieres cambiarle el nombre:</p> <pre><code>git remote rename origin &lt;nuevo-nombre&gt;\n</code></pre> <p>Tambien puedes eliminar un remoto:</p> <pre><code>git remote remove origin\n</code></pre>"},{"location":"git/Repositorios%20Remotos%20Git/#trabajando-con-repositorios","title":"Trabajando Con repositorios","text":"<p>Ya teniendo el repositorio en tu m\u00e1quina local si ejecutas <code>git fetch</code> mira si hay cambios del repositorio remoto comparado con tu repositorio local (solo descarga los cambios del remoto, pero no los fusiona con tu rama local. Para fusionarlos, debes ejecutar git merge o git pull.). En el caso de que haya cambios, puedes ejecutar:</p> <pre><code>git pull \n</code></pre> <p>Esto hace pull al repo que tengas por defecto en upstream, sin tocar nada lo tendras en origin, si quieres otro a continuacion del pull pon el nombre del remoto que quieres. Git pull es una combinaci\u00f3n de git fetch y git merge, lo cual implica que al hacer un pull se traen los cambios y se intentan fusionar con la rama local autom\u00e1ticamente.</p> <p>En este momento, puedes empezar a trabajar como en local y hacer los commits necesarios. Una vez ya terminado tienes que llevar los cambios al repositorio remoto:</p> <pre><code>git push origin main\n</code></pre> <p>Con esto mandas los cambios al remoto origin, a la rama main. Si el nombre de la rama local y la remota no coinciden, tendras que indicar:</p> <pre><code>git push origin &lt;nombrelocal&gt; &lt;nombreremoto&gt;\n</code></pre> <p>Si tienes definido el upstream, es decir, a donde manda por defecto los cambios de esa rama puedes simplemente hacer <code>git push</code>.</p> <p>Para definir el upstream, normalmente cuando lo clonas lo tienes ya definido, pero si creas tu la nueva rama no por lo que tendras que declararlo con <code>-u</code>.</p> <pre><code>git push -u origin main\n</code></pre> <p>Siempre tienes que hacer pull antes de push, si no, el remoto lo rechaza. Si estas trabajando de forma colaborativa y tienes que hacer pull a un cambio, puede provocar un merge conflict.</p>"},{"location":"git/Repositorios%20Remotos%20Git/#pull-rebase","title":"Pull Rebase","text":"<p>Si se da este caso de que alguien ha colaborado a la misma rama y ha enviado cambios antes que t\u00fa. No hagas pull directamente, esto dejar\u00e1 los dos commits y los juntar\u00e1 mediante un nuevo commit de merge. Esto hace muy dificil revisar el repositorio en caso de tener que buscar un error.</p> <p>Para solucionar esto, puedes hacer un pull rebase:</p> <pre><code>git pull --rebase\n</code></pre> <p>Esto lo que hace es quitar tu commit del historial, hacer pull del contenido y posteriormente volver a agregar tu commit a HEAD.</p> <p>El rebase solo funcionar\u00e1 sin conflictos si los cambios en el remoto no afectan las mismas l\u00edneas de c\u00f3digo que tus cambios. Si hay conflictos, debes resolverlos manualmente como si fuera un merge conflict.</p> <pre><code>git rebase --abort\ngit pull\n</code></pre> <p>O tambien puedes corregir el rebase y hacer:</p> <pre><code>git rebase --continue\n</code></pre> <p>Otra alternativa es hacer fetch y merge.</p>"},{"location":"git/Repositorios%20Remotos%20Git/#merge-conflict","title":"Merge Conflict","text":"<p>Un merge conflict ocurre cuando dos ramas diferentes contienen cambios incompatibles en el mismo archivo, y Git no puede determinar autom\u00e1ticamente c\u00f3mo fusionar esos cambios.</p> <p>En este caso, requiere intervenci\u00f3n manual del usuario para resolver el conflicto, decidiendo qu\u00e9 cambios mantener y c\u00f3mo combinarlos adecuadamente.</p> <p>Para solucionar el conflicto, antes de nada hay que localizarlo, <code>git status</code>. Para corregirlo tendr\u00e1s que editar el archivo que da el conflicto ya que git lo ha escrito esperando a mas informacion. Por ejemplo:</p> <pre><code>Hola\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n&lt;h1&gt;Contenido en la rama principal&lt;/h1&gt;\n=======\n&lt;h1&gt;Contenido en la rama1&lt;/h1&gt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; rama1\n</code></pre> <p>Esto es un conflicto simulado entre dos ramas, una main y otra rama1. En tal caso tendras que borrar las lineas para quedarte con el contenido que quieres, en este caso me quedare con el contenido de la rama main.</p> <pre><code>Hola\nContenido en la rama principal\n</code></pre> <p>Ahora le tenemos que informar a git que se ha solucionado:</p> <pre><code>git add .\ngit merge --continue\n</code></pre> <p>Los editores modernos y clientes de git como Code, IntelliJ o Gitkracken te ayuda a hacer esto de modo visual con una GUI pero esta es la forma que se har\u00eda desde consola.</p>"},{"location":"git/Revirtiendo%20Cambios%20Git/","title":"Revirtiendo Cambios","text":"<p>La magia de Git radica en su capacidad para deshacer cambios y volver a una versi\u00f3n anterior del c\u00f3digo en caso de cometer alg\u00fan error.</p>"},{"location":"git/Revirtiendo%20Cambios%20Git/#restore","title":"Restore","text":"<p>Imagina que est\u00e1s trabajando en un archivo en Git y quieres deshacer los cambios realizados en \u00e9l. Para hacerlo, puedes restaurar el archivo a la versi\u00f3n guardada en el \u00faltimo commit (HEAD).</p> <p>Existen varias formas de hacer esto, pero para este caso de uso, utilizaremos el comando <code>restore</code>.</p> <pre><code>git restore &lt;archivo&gt;\n</code></pre> <p>Si especificamos <code>.</code> en lugar de un archivo espec\u00edfico, se restaurar\u00e1n todos los archivos en el directorio de trabajo.</p> <p>Adem\u00e1s, podemos usar <code>restore</code> para regresar a un commit espec\u00edfico.</p> <pre><code>git restore --source &lt;id_commit&gt; -- &lt;archivo&gt;\n</code></pre> <p>El comando <code>restore</code> trae una versi\u00f3n anterior de un archivo a tu directorio de trabajo. Tambi\u00e9n es \u00fatil para recuperar archivos que hayas borrado con <code>rm</code>.</p> <p>Desde Git 2.23, se introdujo el comando <code>git restore</code> como una alternativa m\u00e1s clara y espec\u00edfica a <code>git checkout</code> para deshacer cambios en archivos individuales. Antes de esta versi\u00f3n, <code>git checkout</code> se utilizaba tanto para cambiar de ramas como para restaurar archivos, lo que generaba confusi\u00f3n.</p>"},{"location":"git/Revirtiendo%20Cambios%20Git/#reset","title":"Reset","text":"<p>Cuando borras un archivo con <code>git rm &lt;archivo&gt;</code>, notar\u00e1s que no puedes restaurarlo con <code>git checkout</code>. Esto ocurre porque el archivo ya no est\u00e1 siendo rastreado por Git.</p> <p>Para recuperarlo, puedes usar <code>git reset</code>. Este comando restaura tu directorio de trabajo al estado de un commit espec\u00edfico.</p> <p>Tambi\u00e9n puedes usar <code>git reset</code> para deshacer cambios ya confirmados (commiteados) y regresar a un commit anterior si te das cuenta de que hubo un error.</p> <p>Existen tres modos principales de <code>reset</code>:</p> <ul> <li>Soft (--soft): Mantiene los cambios en el \u00e1rea de preparaci\u00f3n (staging area), lo que significa que puedes volver a hacer commit f\u00e1cilmente.</li> <li>Mixed (--mixed) (por defecto): Elimina los cambios del \u00e1rea de preparaci\u00f3n, pero los mantiene en el directorio de trabajo.</li> <li>Hard (--hard): Elimina completamente los cambios tanto del \u00e1rea de preparaci\u00f3n como del directorio de trabajo. \u00dasalo con precauci\u00f3n, ya que los cambios eliminados no se pueden recuperar, a menos que los hayas guardado en el reflog de Git.</li> </ul> <pre><code>git reset --soft &lt;commit&gt;\ngit reset --mixed &lt;commit&gt;\ngit reset --hard &lt;commit&gt;\n</code></pre>"},{"location":"git/Revirtiendo%20Cambios%20Git/#revert","title":"Revert","text":"<p><code>git revert</code> es un comando que te permite deshacer cambios ya confirmados (commiteados), pero de una manera menos destructiva que <code>reset</code>.</p> <p>En lugar de modificar la historia de commits, <code>git revert</code> crea un nuevo commit que deshace los cambios de un commit espec\u00edfico.</p> <pre><code>git revert &lt;commit&gt;\n</code></pre> <p>Tambi\u00e9n puedes revertir una serie de commits. Esto tambi\u00e9n se puede aplicar a <code>git revert</code>:</p> <pre><code>git revert -n master~5..master~2\n</code></pre> <p>Este comando revierte los cambios desde <code>master~5</code> hasta <code>master~2</code>, pero los deja en el \u00e1rea de preparaci\u00f3n para que los revises antes de hacer un nuevo commit.</p>"},{"location":"git/Revirtiendo%20Cambios%20Git/#cuando-usar-reset-y-cuando-revert","title":"\u00bfCu\u00e1ndo usar reset y cu\u00e1ndo revert?","text":"<ul> <li>Usa <code>reset</code> cuando quieras modificar la historia de commits, especialmente si los cambios no se han compartido a\u00fan con otros colaboradores en el repositorio remoto.</li> <li>Usa <code>revert</code> cuando necesites deshacer un commit sin perder la historia ni afectar a otros colaboradores en el repositorio.</li> </ul>"}]}